<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - exporter - stl</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="src/styles.css" />
  </head>
  <body>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
      webgl - exporter - stl<br /><br />
      <button id="exportASCII">export ASCII</button>
      <button id="exportBinary">export binary</button>
    </div>

    <script type="module">
      import * as THREE from "https://threejs.org/build/three.module.js";

      import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";
      import { STLExporter } from "https://threejs.org/examples/jsm/exporters/STLExporter.js";

      import { WEBGL } from "https://threejs.org/examples/jsm/WebGL.js";

      let scene, camera, renderer, exporter, mesh, cylinderMesh;

      init();
      animate();

      function init() {
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(200, 100, 200);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xa0a0a0);
        scene.fog = new THREE.Fog(0xa0a0a0, 200, 1000);

        exporter = new STLExporter();

        //

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 200, 0);
        scene.add(hemiLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set(0, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.top = 180;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.camera.left = -120;
        directionalLight.shadow.camera.right = 120;
        scene.add(directionalLight);

        // ground

        const ground = new THREE.Mesh(
          new THREE.PlaneGeometry(2000, 2000),
          new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const grid = new THREE.GridHelper(2000, 20, 0x000000, 0x000000);
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid);

        // export mesh

        const geometry = new THREE.BoxGeometry(50, 50, 50);
        const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });

        mesh = new THREE.Mesh(geometry, material);
        mesh.castShadow = true;
        mesh.position.y = 25;
        //scene.add( mesh );

        //
        // https://threejsfundamentals.org/threejs/lessons/threejs-custom-buffergeometry.html
        // https://github.com/mrdoob/three.js/blob/master/examples/webgl2_buffergeometry_attributes_integer.html

        const customGeometry = new THREE.BufferGeometry();

        const positions = [];
        const indices = [];

        const iRes = 100;
        const jRes = 100;

        const cylinderRadius = 70;
        const cylinderHight = 140;

        const thick = 2;

        var startIndex = positions.length / 3;

        console.log(startIndex);

        for (var j = 0; j < jRes; ++j) {
          var y = (cylinderHight / jRes) * j;

          for (var i = 0; i < iRes; ++i) {
            const rad = ((Math.PI * 2) / iRes) * i;

            var x = Math.cos(rad) * cylinderRadius;
            var z = Math.sin(rad) * cylinderRadius;

            positions.push(x, y, z);

            if (j < jRes - 1) {
              var i1 = i + 1 == iRes ? 0 : i + 1;
              var j1 = j + 1 == jRes ? 0 : j + 1;

              indices.push(
                startIndex + (i + j * iRes),
                startIndex + (i1 + j * iRes),
                startIndex + (i + j1 * iRes)
              );
              indices.push(
                startIndex + (i + j1 * iRes),
                startIndex + (i1 + j * iRes),
                startIndex + (i1 + j1 * iRes)
              );
            }
          }
        }

        var startIndex = positions.length / 3;
        console.log(startIndex);

        for (var j = 0; j < jRes; ++j) {
          var y = (cylinderHight / jRes) * j;

          for (var i = 0; i < iRes; ++i) {
            const rad = ((Math.PI * 2) / iRes) * i;

            var x = Math.cos(rad) * (cylinderRadius + thick);
            var z = Math.sin(rad) * (cylinderRadius + thick);

            positions.push(x, y, z);

            if (j < jRes - 1) {
              var i1 = i + 1 == iRes ? 0 : i + 1;
              var j1 = j + 1 == jRes ? 0 : j + 1;

              indices.push(
                startIndex + (i + j * iRes),
                startIndex + (i + j1 * iRes),
                startIndex + (i1 + j * iRes)
              );
              indices.push(
                startIndex + (i + j1 * iRes),
                startIndex + (i1 + j1 * iRes),
                startIndex + (i1 + j * iRes)
              );
            }
          }
        }

        const stride = iRes * jRes;

        for (var i = 0; i < iRes; ++i) {
          var i1 = i + 1 == iRes ? 0 : i + 1;

          indices.push(i, i + stride, i1);
          indices.push(i + stride, i1 + stride, i1);

          var j = jRes - 1;

          indices.push(j * iRes + i, j * iRes + i1, j * iRes + i + stride);
          indices.push(
            j * iRes + i + stride,
            j * iRes + i1,
            j * iRes + i1 + stride
          );
        }

        // itemSize = 3 because there are 3 values (components) per vertex
        customGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3)
        );

        customGeometry.setIndex(indices);

        const customMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const wireframeMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          wireframe: true
        });

        cylinderMesh = new THREE.Mesh(customGeometry, wireframeMaterial);

        cylinderMesh.castShadow = true;

        scene.add(cylinderMesh);

        //

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        //

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 25, 0);
        controls.update();

        //

        window.addEventListener("resize", onWindowResize);

        const buttonExportASCII = document.getElementById("exportASCII");
        buttonExportASCII.addEventListener("click", exportASCII);

        const buttonExportBinary = document.getElementById("exportBinary");
        buttonExportBinary.addEventListener("click", exportBinary);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }

      function exportASCII() {
        const result = exporter.parse(cylinderMesh);
        saveString(result, "box.stl");
      }

      function exportBinary() {
        const result = exporter.parse(cylinderMesh, { binary: true });
        saveArrayBuffer(result, "box.stl");
      }

      const link = document.createElement("a");
      link.style.display = "none";
      document.body.appendChild(link);

      function save(blob, filename) {
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      }

      function saveString(text, filename) {
        save(new Blob([text], { type: "text/plain" }), filename);
      }

      function saveArrayBuffer(buffer, filename) {
        save(
          new Blob([buffer], { type: "application/octet-stream" }),
          filename
        );
      }
    </script>
  </body>
</html>
